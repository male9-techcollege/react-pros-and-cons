/* This is based on the style sheets for global styles that were created by Vite. */
/* Source for way to fold regions in .jsx files: https://stackoverflow.com/questions/58882591/region-for-jsx */
// #region .scss versus .module.scss:
/* ABOUT .scss versus .module.scss: 
Interestingly, my tests in this project and another project showed the following: 
- If I rename this global style sheet something.module.scss, I lose some (but not all) of the styling. 
  (The global footer was no longer sent to the bottom in my react-gallery-wrapper assignment, which I just started.)
- It is possible to import a style sheet named something.scss (not something.module.scss) in App.tsx and main.tsx. 
  However, the teacher said that it would not work (or is not supposed to work) in the files where the components are defined.
  I changed the extension from .css to .scss because I @used variables in here.
Maybe TO DO: ask why
The following is an old source about the deprecated create-react-app, which we are not using, but this is probably the answer: 
"By default, create-react-app 2.0.0 treats any file that follows the *.module.scss pattern as modular 
and any other *.scss files as global."
https: //medium.com/clover-platform-blog/modular-scss-and-why-you-need-it-6bb2d8c40fd8

"Global styles 
In some cases, you may need to use global styles in CSS Modules,
such as overriding the styles of third-party libraries or setting global styles for specific elements."
https://rsbuild.rs/guide/styling/css-modules#css-modules-recognition-rules
Note: Rsbuild does use React.
"Rsbuild provides a rich set of build features, including support for TypeScript, JSX, Sass, Less, CSS Modules, Wasm, and more."
https: //rsbuild.rs/guide/start/

"One great usage of SASS is to store the various colors used in your app as variables. These variables can then be referenced in other .scss files,
or in this case directly in your React components. (...) But if you want to extract this color to use directly in a React component,
youâ€™ll have to make the following updates: (...)
// Rename _colors.scss to _colors.module.scss
$primaryColor: $1d6dd3;
:export {
    primary: $primaryColor;
}
Adding the .module part into the filename allows it to be imported into a React component and any key-value pair in the :export section is accessible like this: 
// CircleSvg.js
import colors from '_colors.module.scss';
function CircleSvg() {
    return <svg><g fill= {colors.primary}>...</g></svg>;
}
(...)
Your existing .scss files can still import the file as normal just by adding the .module part to the filename.
"
https://medium.com/@UReyesMeUp/using-sass-variables-in-your-react-components-e3813a6cc81e
Note: since we don't need to use :export, I am thinking that this source is either too old (2019) 
or based on another tech stack than the one we are using. 
*/
// #endregion .scss versus .module.scss:

/* I opted for not using Tailwind because it implements styling over which I have no control on top of my SCSS styling.
More work for nothing! */
/* @use "tailwindcss"; */
@use "./styles/_sizes.scss" as *;
@use "./styles/colors.module.scss" as *;

/* If I add the following universal selector, the body element's default margin of 8px (provided by the browser)
does disappear (see DevTools, Elements tab, and then body styling under "user agent stylesheet"). 
* {
    margin: 0;
}
*/

:root {
    font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
    line-height: 1.5;
    font-weight: 400;

    /* The CSS declaration color-scheme: light dark; 
    is used to change the colour scheme based on user preferences, set in browser or device settings. 
    It is not part of how the toggle button works. 
    Source: 
    https://medium.com/@dimterion/css-light-dark-prefers-color-scheme-js-theme-toggle-db66e2a00be0
    
    I am still hiding it because if I activate that function, it overrides some of my styling (at least the text colour
    of buttons).
    color-scheme: light dark; 
    */
    color: $clr-white;
    background-color: $clr-dark-grey;

    font-synthesis: none;
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;

    /* Addition to styling from file index.css. */
    font-size: 18px;
}

:root body>div {
    color: $clr-white;
    background-color: $clr-dark-grey;
}

/* #root is a div in the index.html file 
IMPORTANT: #root and :root are not the same element!
Known facts: 
*    #root (<div id="root" ></div> in the .html file) is the parent of <App />
*    According to DevTools, :root is the html element since the styling (e.g. font-size: 18px; ) is listed 
     under "Inherited from html" in the tab Elements. 
**    That is amazing to me because this scss file is NOT imported by the HTML file. It is imported by main.tsx, 
      which creates a root element with: 
      createRoot(document.getElementById('root')!).render();
      So how can the styling apply to an ancestor of #root?
Q:
Is :root the component <App />, the parent of <App /> (#root) or the html element?
A:
I am guessing that the transpiler makes the index.scss file the main SCSS file for the entire page, 
even though it is not imported with a link element in index.html at the development stage. The program must be importing 
the "index" style sheet into the HTML file, perhaps at build time. It is possible to add elements in the head element with JS.
*/
#rootByMariePierreLessard {
    /* A little styling from the file index.css remains,
    but I changed a lot. */
    margin: 0 auto;
    /* This padding is on top of the default margin on body (from the user-agent stylesheet).
    That margin is still there because there is no universal selector in this project. */
    padding: 2rem;
    max-width: $max-width;

    /* Normally, this styling is applied to body in order to send the footer all the way to the bottom on all screens. 
    However, it is not possible to access the body element from the app since the app is in a div inside of body. 
    It works to apply this styling to #root instead. */
    display: grid;
    grid-template-columns: 1fr;
    grid-template-rows: auto auto 1fr auto;
    min-height: 100vh;
}

a {
    font-weight: 500;
    color: $clr-vites-default-purple;
    text-decoration: none;
}

a:hover {
    color: $clr-vites-default-dark-purple-dm;
    text-decoration: underline;
}

/* This applies to nav and modal buttons, although some of it is overridden. */
button {
    border: 1px solid transparent;
    transition: border-color 0.25s;
    padding: 0.6em 1.2em;
    font-size: 1em;
    font-weight: 500;
    font-family: inherit;
    background-color: $clr-white;
    cursor: pointer;
    align-content: center;
}

button:hover {
    background-color: $clr-react-blue;
}

button:focus,
button:focus-visible {
    outline: 4px auto -webkit-focus-ring-color;
    outline-offset: 2px;
}

button:active {
    background-color: $clr-vites-default-purple;
}

/* Research on the following media query.
The styling of Vite's default project includes the following declarations for a light colour theme. I edited the values a bit.
The default colour scheme, declared in the scope of the :root selector, is dark. This media query only works based on 
user preferences set in the browser or device settings. It cannot be used to create a button to switch between the two 
according to 
https: //stackoverflow.com/questions/73155601/is-it-possible-to-trigger-css-prefers-color-scheme-in-js 
As explained by the MDN page https: //developer.mozilla.org/en-US/docs/Web/CSS/Reference/At-rules/@media/prefers-color-scheme , 
if the user sets a preference for the color scheme applied by the media query, then the media query is excuted. 
This is NOT fully supported by all browsers.
*/
@media (prefers-color-scheme: light) {
    :root {
        color: $clr-dark-grey;
        background-color: $clr-white;
    }

    a:hover {
        color: $clr-vites-default-light-purple-lm;
    }
}

/* The following is a copy of the CSS declarations in the media query above.
Its purpose is to allow for the toggling of the colour mode with a button (toggle switch). 

.light body>div
represents the #root element. It is necessary to give it the background colour of :root,
or the modal does not inherit the background colour set by the colour-mode toggle switch/button. 
*/
.light,
.light body > div {
    color: $clr-dark-grey;
    background-color: $clr-white;

    a:hover {
        color: $clr-vites-default-light-purple-lm;
    }
}